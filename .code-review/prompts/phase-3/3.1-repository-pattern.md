# Milestone 3.1: Implement Repository Pattern

> **Phase:** 3 - Code Quality & Architecture
> **Priority:** MEDIUM
> **Status:** Done
> **Last Updated:** 2025-12-27

---

## Problem Description

Direct Firebase calls are scattered across screens and services, making the code:
1. Hard to test (Firebase dependency)
2. Hard to mock for unit tests
3. Difficult to swap data sources
4. Violating separation of concerns

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                        UI Layer                              │
│  (Screens, Widgets)                                         │
└─────────────────────────────┬───────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    State Management                          │
│  (Cubits, BLoCs)                                            │
└─────────────────────────────┬───────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   Repository Layer (NEW)                     │
│  (ChildRepository, TestResultRepository, UserRepository)    │
└─────────────────────────────┬───────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                     Data Sources                             │
│  (FirebaseDataSource, LocalDataSource)                      │
└─────────────────────────────────────────────────────────────┘
```

---

## Required Changes

### Step 1: Create repository interfaces

Create `lib/core/repositories/child_repository.dart`:

```dart
import 'package:khuta/models/child.dart';

abstract class ChildRepository {
  /// Get all children for the current user
  Future<List<Child>> getChildren();

  /// Get a single child by ID
  Future<Child?> getChild(String childId);

  /// Add a new child
  Future<String> addChild(Child child);

  /// Update a child
  Future<void> updateChild(Child child);

  /// Soft delete a child
  Future<void> deleteChild(String childId);

  /// Stream of children for real-time updates
  Stream<List<Child>> watchChildren();
}
```

Create `lib/core/repositories/test_result_repository.dart`:

```dart
import 'package:khuta/models/test_result.dart';

abstract class TestResultRepository {
  /// Get all test results for a child
  Future<List<TestResult>> getTestResults(String childId);

  /// Get a single test result
  Future<TestResult?> getTestResult(String childId, String resultId);

  /// Save a new test result
  Future<String> saveTestResult(String childId, TestResult result);

  /// Stream of test results for real-time updates
  Stream<List<TestResult>> watchTestResults(String childId);
}
```

### Step 2: Create Firebase implementations

Create `lib/data/repositories/firebase_child_repository.dart`:

```dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:khuta/core/repositories/child_repository.dart';
import 'package:khuta/models/child.dart';

class FirebaseChildRepository implements ChildRepository {
  final FirebaseFirestore _firestore;
  final FirebaseAuth _auth;

  FirebaseChildRepository({
    FirebaseFirestore? firestore,
    FirebaseAuth? auth,
  })  : _firestore = firestore ?? FirebaseFirestore.instance,
        _auth = auth ?? FirebaseAuth.instance;

  String? get _userId => _auth.currentUser?.uid;

  CollectionReference<Map<String, dynamic>> get _childrenCollection {
    if (_userId == null) throw Exception('User not authenticated');
    return _firestore
        .collection('users')
        .doc(_userId)
        .collection('children');
  }

  @override
  Future<List<Child>> getChildren() async {
    final snapshot = await _childrenCollection
        .where('isDeleted', isNotEqualTo: true)
        .orderBy('isDeleted')
        .orderBy('createdAt', descending: false)
        .get();

    return snapshot.docs
        .map((doc) => Child.fromFirestore(doc))
        .toList();
  }

  @override
  Future<Child?> getChild(String childId) async {
    final doc = await _childrenCollection.doc(childId).get();
    if (!doc.exists) return null;
    return Child.fromFirestore(doc);
  }

  @override
  Future<String> addChild(Child child) async {
    final docRef = await _childrenCollection.add(child.toFirestore());
    return docRef.id;
  }

  @override
  Future<void> updateChild(Child child) async {
    await _childrenCollection.doc(child.id).update(child.toFirestore());
  }

  @override
  Future<void> deleteChild(String childId) async {
    await _childrenCollection.doc(childId).update({
      'isDeleted': true,
      'deletedAt': FieldValue.serverTimestamp(),
    });
  }

  @override
  Stream<List<Child>> watchChildren() {
    return _childrenCollection
        .where('isDeleted', isNotEqualTo: true)
        .orderBy('isDeleted')
        .orderBy('createdAt', descending: false)
        .snapshots()
        .map((snapshot) =>
            snapshot.docs.map((doc) => Child.fromFirestore(doc)).toList());
  }
}
```

### Step 3: Update Child model for Firestore

Update `lib/models/child.dart`:

```dart
import 'package:cloud_firestore/cloud_firestore.dart';

class Child {
  final String? id;
  final String name;
  final int age;
  final String gender;
  final DateTime createdAt;
  final bool isDeleted;

  Child({
    this.id,
    required this.name,
    required this.age,
    required this.gender,
    DateTime? createdAt,
    this.isDeleted = false,
  }) : createdAt = createdAt ?? DateTime.now();

  factory Child.fromFirestore(DocumentSnapshot<Map<String, dynamic>> doc) {
    final data = doc.data()!;
    return Child(
      id: doc.id,
      name: data['name'] as String,
      age: data['age'] as int,
      gender: data['gender'] as String,
      createdAt: (data['createdAt'] as Timestamp).toDate(),
      isDeleted: data['isDeleted'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'name': name,
      'age': age,
      'gender': gender,
      'createdAt': Timestamp.fromDate(createdAt),
      'isDeleted': isDeleted,
    };
  }

  Child copyWith({
    String? id,
    String? name,
    int? age,
    String? gender,
    DateTime? createdAt,
    bool? isDeleted,
  }) {
    return Child(
      id: id ?? this.id,
      name: name ?? this.name,
      age: age ?? this.age,
      gender: gender ?? this.gender,
      createdAt: createdAt ?? this.createdAt,
      isDeleted: isDeleted ?? this.isDeleted,
    );
  }
}
```

### Step 4: Create repository provider

Create `lib/core/di/service_locator.dart`:

```dart
import 'package:khuta/core/repositories/child_repository.dart';
import 'package:khuta/core/repositories/test_result_repository.dart';
import 'package:khuta/data/repositories/firebase_child_repository.dart';
import 'package:khuta/data/repositories/firebase_test_result_repository.dart';

class ServiceLocator {
  static final ServiceLocator _instance = ServiceLocator._internal();
  factory ServiceLocator() => _instance;
  ServiceLocator._internal();

  ChildRepository? _childRepository;
  TestResultRepository? _testResultRepository;

  ChildRepository get childRepository {
    _childRepository ??= FirebaseChildRepository();
    return _childRepository!;
  }

  TestResultRepository get testResultRepository {
    _testResultRepository ??= FirebaseTestResultRepository();
    return _testResultRepository!;
  }

  /// For testing - allows injecting mock repositories
  void registerChildRepository(ChildRepository repository) {
    _childRepository = repository;
  }

  void registerTestResultRepository(TestResultRepository repository) {
    _testResultRepository = repository;
  }

  void reset() {
    _childRepository = null;
    _testResultRepository = null;
  }
}
```

### Step 5: Update screens to use repositories

Update `lib/screens/home/home_screen.dart`:

```dart
class _HomeScreenState extends State<HomeScreen> {
  final ChildRepository _childRepository = ServiceLocator().childRepository;

  // Replace direct Firestore calls with repository calls
  Future<void> _loadChildren() async {
    try {
      final children = await _childRepository.getChildren();
      setState(() {
        _children = children;
        _isLoading = false;
      });
    } catch (e) {
      // Handle error
    }
  }
}
```

---

## Directory Structure

```
lib/
├── core/
│   ├── repositories/
│   │   ├── child_repository.dart        # Interface
│   │   └── test_result_repository.dart  # Interface
│   └── di/
│       └── service_locator.dart         # Dependency injection
├── data/
│   └── repositories/
│       ├── firebase_child_repository.dart
│       └── firebase_test_result_repository.dart
└── models/
    ├── child.dart                       # Updated with Firestore methods
    └── test_result.dart                 # Updated with Firestore methods
```

---

## Acceptance Criteria

- [x] Repository interfaces created
- [x] Firebase implementations created
- [x] Models updated with Firestore serialization
- [x] Service locator created
- [x] Screens updated to use repositories
- [x] All existing functionality works
- [x] `flutter analyze` passes

---

## Files to Create/Modify

| File | Action |
|------|--------|
| `lib/core/repositories/child_repository.dart` | Create interface |
| `lib/core/repositories/test_result_repository.dart` | Create interface |
| `lib/data/repositories/firebase_child_repository.dart` | Create implementation |
| `lib/data/repositories/firebase_test_result_repository.dart` | Create implementation |
| `lib/core/di/service_locator.dart` | Create DI container |
| `lib/models/child.dart` | Add Firestore methods |
| `lib/models/test_result.dart` | Add Firestore methods |
| `lib/screens/home/home_screen.dart` | Use repository |
| `lib/screens/child/assessment/services/assessment_service.dart` | Use repository |

---

## Progress Tracking

- [x] Step 1: Create repository interfaces
- [x] Step 2: Create Firebase implementations
- [x] Step 3: Update models
- [x] Step 4: Create service locator
- [x] Step 5: Update screens
- [x] Step 6: Test all functionality
- [x] Step 7: Update checklist

---

## Completion

When done, update:
1. `.code-review/MASTER_PLAN.md` - Change milestone 3.1 status to "Done"
2. `.code-review/checklists/phase-3-checklist.md` - Mark item complete
