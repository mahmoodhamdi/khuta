# Milestone 3.2: Error Handling & Resilience

> **Phase:** 3 - Code Quality & Architecture
> **Priority:** MEDIUM
> **Status:** Done
> **Last Updated:** 2025-12-27

---

## Problem Description

Current error handling issues:
1. Silent failures in many places (PDF generation, AI recommendations)
2. No retry logic for network operations
3. Generic error messages not helpful to users
4. No centralized error reporting
5. Missing connectivity checks

---

## Required Changes

### Step 1: Create custom exception classes

Create `lib/core/exceptions/app_exceptions.dart`:

```dart
/// Base exception for all app exceptions
abstract class AppException implements Exception {
  final String message;
  final String? code;
  final dynamic originalException;

  AppException(this.message, {this.code, this.originalException});

  @override
  String toString() => 'AppException: $message (code: $code)';
}

/// Network-related exceptions
class NetworkException extends AppException {
  NetworkException(super.message, {super.code, super.originalException});
}

/// Authentication-related exceptions
class AuthException extends AppException {
  AuthException(super.message, {super.code, super.originalException});
}

/// Data/Firebase exceptions
class DataException extends AppException {
  DataException(super.message, {super.code, super.originalException});
}

/// Validation exceptions
class ValidationException extends AppException {
  final Map<String, String>? fieldErrors;

  ValidationException(super.message, {super.code, this.fieldErrors});
}

/// AI Service exceptions
class AIServiceException extends AppException {
  AIServiceException(super.message, {super.code, super.originalException});
}
```

### Step 2: Create error handler service

Create `lib/core/services/error_handler_service.dart`:

```dart
import 'package:flutter/foundation.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:easy_localization/easy_localization.dart';
import '../exceptions/app_exceptions.dart';

class ErrorHandlerService {
  /// Converts any exception to an AppException with user-friendly message
  static AppException handleException(dynamic error) {
    debugPrint('Error occurred: $error');

    // Firebase Auth errors
    if (error is FirebaseAuthException) {
      return _handleAuthException(error);
    }

    // Firestore errors
    if (error is FirebaseException) {
      return _handleFirestoreException(error);
    }

    // Network errors
    if (error.toString().contains('SocketException') ||
        error.toString().contains('NetworkException') ||
        error.toString().contains('XMLHttpRequest')) {
      return NetworkException(
        'network_error'.tr(),
        code: 'NETWORK_ERROR',
        originalException: error,
      );
    }

    // Already an AppException
    if (error is AppException) {
      return error;
    }

    // Unknown error
    return AppException(
      'unexpected_error'.tr(),
      code: 'UNKNOWN',
      originalException: error,
    );
  }

  static AuthException _handleAuthException(FirebaseAuthException error) {
    String message;
    switch (error.code) {
      case 'user-not-found':
        message = 'error_user_not_found'.tr();
        break;
      case 'wrong-password':
        message = 'error_wrong_password'.tr();
        break;
      case 'email-already-in-use':
        message = 'error_email_in_use'.tr();
        break;
      case 'weak-password':
        message = 'error_weak_password'.tr();
        break;
      case 'invalid-email':
        message = 'error_invalid_email'.tr();
        break;
      case 'too-many-requests':
        message = 'error_too_many_requests'.tr();
        break;
      default:
        message = 'error_auth_generic'.tr();
    }
    return AuthException(message, code: error.code, originalException: error);
  }

  static DataException _handleFirestoreException(FirebaseException error) {
    String message;
    switch (error.code) {
      case 'permission-denied':
        message = 'error_permission_denied'.tr();
        break;
      case 'unavailable':
        message = 'error_service_unavailable'.tr();
        break;
      case 'not-found':
        message = 'error_data_not_found'.tr();
        break;
      default:
        message = 'error_data_generic'.tr();
    }
    return DataException(message, code: error.code, originalException: error);
  }
}
```

### Step 3: Create retry utility

Create `lib/core/utils/retry_helper.dart`:

```dart
import 'dart:async';
import 'package:flutter/foundation.dart';

class RetryHelper {
  /// Retries an async operation with exponential backoff
  static Future<T> retry<T>({
    required Future<T> Function() operation,
    int maxAttempts = 3,
    Duration initialDelay = const Duration(seconds: 1),
    double backoffFactor = 2.0,
    bool Function(Exception)? shouldRetry,
  }) async {
    int attempt = 0;
    Duration delay = initialDelay;

    while (true) {
      try {
        attempt++;
        return await operation();
      } catch (e) {
        if (attempt >= maxAttempts) {
          rethrow;
        }

        if (e is Exception && shouldRetry != null && !shouldRetry(e)) {
          rethrow;
        }

        debugPrint('Retry attempt $attempt failed: $e. Retrying in $delay...');
        await Future.delayed(delay);
        delay *= backoffFactor;
      }
    }
  }
}
```

### Step 4: Create connectivity service

Create `lib/core/services/connectivity_service.dart`:

```dart
import 'package:connectivity_plus/connectivity_plus.dart';

class ConnectivityService {
  final Connectivity _connectivity = Connectivity();

  /// Check if device has internet connection
  Future<bool> hasConnection() async {
    final result = await _connectivity.checkConnectivity();
    return !result.contains(ConnectivityResult.none);
  }

  /// Stream of connectivity changes
  Stream<bool> get onConnectivityChanged {
    return _connectivity.onConnectivityChanged
        .map((result) => !result.contains(ConnectivityResult.none));
  }

  /// Throws NetworkException if no connection
  Future<void> ensureConnected() async {
    if (!await hasConnection()) {
      throw NetworkException('no_internet_connection'.tr());
    }
  }
}
```

### Step 5: Create error boundary widget

Create `lib/widgets/error_boundary.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:easy_localization/easy_localization.dart';

class ErrorBoundary extends StatefulWidget {
  final Widget child;
  final Widget Function(FlutterErrorDetails)? errorBuilder;

  const ErrorBoundary({
    super.key,
    required this.child,
    this.errorBuilder,
  });

  @override
  State<ErrorBoundary> createState() => _ErrorBoundaryState();
}

class _ErrorBoundaryState extends State<ErrorBoundary> {
  FlutterErrorDetails? _error;

  @override
  void initState() {
    super.initState();
    FlutterError.onError = (details) {
      setState(() => _error = details);
    };
  }

  @override
  Widget build(BuildContext context) {
    if (_error != null) {
      return widget.errorBuilder?.call(_error!) ?? _defaultErrorWidget();
    }
    return widget.child;
  }

  Widget _defaultErrorWidget() {
    return Scaffold(
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.error_outline, size: 64, color: Colors.red),
              const SizedBox(height: 16),
              Text(
                'something_went_wrong'.tr(),
                style: const TextStyle(fontSize: 18),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 24),
              ElevatedButton(
                onPressed: () => setState(() => _error = null),
                child: Text('try_again'.tr()),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

### Step 6: Update AI Recommendations Service with retry

Update `lib/core/services/ai_recommendations_service.dart`:

```dart
static Future<List<String>> getRecommendations(
  int tScore,
  List<Question> questions,
  List<int> answers, {
  int? childAge,
  String? childGender,
}) async {
  try {
    // Check connectivity first
    final connectivity = ConnectivityService();
    await connectivity.ensureConnected();

    // Retry AI call up to 3 times
    final response = await RetryHelper.retry(
      operation: () async {
        final prompt = [
          Content.text(_formatPrompt(questions, answers, tScore, childAge, childGender))
        ];
        return await model.generateContent(prompt);
      },
      maxAttempts: 3,
      initialDelay: const Duration(seconds: 2),
    );

    if (response.text == null || response.text!.isEmpty) {
      return _getFallbackRecommendations(
        tScore: tScore,
        language: _detectLanguage(questions),
      );
    }

    return _parseRecommendations(response.text!);
  } catch (e) {
    debugPrint('Error generating AI recommendations: $e');
    // Return fallback recommendations on error
    return _getFallbackRecommendations(
      tScore: tScore,
      language: _detectLanguage(questions),
    );
  }
}
```

### Step 7: Add translation keys for errors

Add to `assets/translations/en.json`:
```json
{
  "network_error": "Network error. Please check your connection.",
  "unexpected_error": "An unexpected error occurred. Please try again.",
  "no_internet_connection": "No internet connection",
  "error_permission_denied": "You don't have permission to perform this action",
  "error_service_unavailable": "Service temporarily unavailable. Please try again later.",
  "error_data_not_found": "Data not found",
  "error_data_generic": "An error occurred while accessing data",
  "error_auth_generic": "Authentication error",
  "something_went_wrong": "Something went wrong",
  "try_again": "Try Again"
}
```

---

## Acceptance Criteria

- [x] Custom exception classes created
- [x] Error handler service created
- [x] Retry helper implemented
- [x] Connectivity service created
- [x] Error boundary widget created
- [x] AI service uses retry logic
- [x] All translation keys added
- [x] `flutter analyze` passes

---

## Files to Create/Modify

| File | Action |
|------|--------|
| `lib/core/exceptions/app_exceptions.dart` | Create |
| `lib/core/services/error_handler_service.dart` | Create |
| `lib/core/utils/retry_helper.dart` | Create |
| `lib/core/services/connectivity_service.dart` | Create |
| `lib/widgets/error_boundary.dart` | Create |
| `lib/core/services/ai_recommendations_service.dart` | Add retry |
| `assets/translations/en.json` | Add error keys |
| `assets/translations/ar.json` | Add error keys |

---

## Progress Tracking

- [x] Step 1: Create exception classes
- [x] Step 2: Create error handler
- [x] Step 3: Create retry helper
- [x] Step 4: Create connectivity service
- [x] Step 5: Create error boundary
- [x] Step 6: Update AI service
- [x] Step 7: Add translations
- [x] Step 8: Test error scenarios
- [x] Step 9: Update checklist

---

## Completion

When done, update:
1. `.code-review/MASTER_PLAN.md` - Change milestone 3.2 status to "Done"
2. `.code-review/checklists/phase-3-checklist.md` - Mark item complete
