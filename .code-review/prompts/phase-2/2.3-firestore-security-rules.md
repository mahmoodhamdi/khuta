# Milestone 2.3: Firestore Security Rules

> **Phase:** 2 - Security Hardening
> **Priority:** HIGH
> **Status:** Pending
> **Last Updated:** 2025-12-27

---

## Problem Description

Firestore security rules must be properly configured to ensure:
1. Users can only access their own data
2. Data validation is enforced
3. No unauthorized access is possible

---

## Required Changes

### Step 1: Review current data structure

```
Read: D:\khuta\lib\screens\home\home_screen.dart
Read: D:\khuta\lib\screens\child\assessment\services\assessment_service.dart
```

Based on the code, the Firestore structure is:
```
users/
  {userId}/
    children/
      {childId}/
        - name: string
        - age: number
        - gender: string
        - createdAt: timestamp
        - isDeleted: boolean
        testResults/
          {testResultId}/
            - score: number
            - interpretation: string
            - recommendations: array
            - assessmentType: string
            - date: timestamp
```

### Step 2: Create Firestore Security Rules

Create/update `firestore.rules`:

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper function to check if user owns the resource
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Helper function to validate child data
    function isValidChild() {
      let data = request.resource.data;
      return data.keys().hasAll(['name', 'age', 'gender', 'createdAt'])
        && data.name is string
        && data.name.size() > 0
        && data.name.size() <= 100
        && data.age is number
        && data.age >= 1
        && data.age <= 100
        && data.gender in ['male', 'female']
        && data.createdAt is timestamp;
    }

    // Helper function to validate test result data
    function isValidTestResult() {
      let data = request.resource.data;
      return data.keys().hasAll(['score', 'interpretation', 'date', 'assessmentType'])
        && data.score is number
        && data.score >= 0
        && data.interpretation is string
        && data.date is timestamp
        && data.assessmentType is string;
    }

    // Users collection - no direct access
    match /users/{userId} {
      // Users cannot read/write user documents directly
      allow read, write: if false;

      // Children subcollection
      match /children/{childId} {
        // Only owner can read their children
        allow read: if isOwner(userId);

        // Only owner can create children with valid data
        allow create: if isOwner(userId) && isValidChild();

        // Only owner can update (soft delete) children
        allow update: if isOwner(userId)
          && request.resource.data.diff(resource.data).affectedKeys()
              .hasOnly(['isDeleted', 'updatedAt']);

        // Prevent hard deletes - use soft delete instead
        allow delete: if false;

        // Test results subcollection
        match /testResults/{resultId} {
          // Only owner can read test results
          allow read: if isOwner(userId);

          // Only owner can create test results with valid data
          allow create: if isOwner(userId) && isValidTestResult();

          // Test results are immutable - no updates or deletes
          allow update, delete: if false;
        }
      }
    }

    // Catch-all: deny everything else
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
```

### Step 3: Deploy security rules

```bash
# Install Firebase CLI if not installed
npm install -g firebase-tools

# Login to Firebase
firebase login

# Initialize Firebase in project (if not done)
firebase init firestore

# Deploy rules
firebase deploy --only firestore:rules
```

### Step 4: Update app code for soft deletes

Ensure the app uses soft deletes instead of hard deletes:

```dart
// In HomeScreen or wherever delete is implemented
Future<void> deleteChild(String childId) async {
  final user = FirebaseAuth.instance.currentUser;
  if (user == null) return;

  await FirebaseFirestore.instance
      .collection('users')
      .doc(user.uid)
      .collection('children')
      .doc(childId)
      .update({
        'isDeleted': true,
        'updatedAt': FieldValue.serverTimestamp(),
      });
}
```

### Step 5: Filter out soft-deleted children in queries

```dart
// In HomeScreen
final querySnapshot = await _firestore
    .collection('users')
    .doc(user.uid)
    .collection('children')
    .where('isDeleted', isNotEqualTo: true)  // Filter out deleted
    .orderBy('isDeleted')  // Required for inequality filter
    .orderBy('createdAt', descending: false)
    .get();
```

---

## Testing Security Rules

Use Firebase Emulator to test rules:

```bash
# Start emulator
firebase emulators:start --only firestore

# Run security rules tests
firebase emulators:exec --only firestore "npm test"
```

Example test file `firestore.rules.test.js`:

```javascript
const { assertFails, assertSucceeds } = require('@firebase/rules-unit-testing');

describe('Firestore Security Rules', () => {
  it('allows users to read their own children', async () => {
    const db = getFirestore({ uid: 'user1' });
    await assertSucceeds(db.collection('users/user1/children').get());
  });

  it('denies users from reading other users children', async () => {
    const db = getFirestore({ uid: 'user1' });
    await assertFails(db.collection('users/user2/children').get());
  });

  it('denies unauthenticated access', async () => {
    const db = getFirestore(null);
    await assertFails(db.collection('users/user1/children').get());
  });
});
```

---

## Acceptance Criteria

- [ ] Security rules deployed to Firebase
- [ ] Users can only access their own data
- [ ] Data validation enforced on write
- [ ] Soft delete implemented instead of hard delete
- [ ] All existing app functionality works
- [ ] Security rules tested

---

## Files to Modify/Create

| File | Action |
|------|--------|
| `firestore.rules` | Create security rules |
| `lib/screens/home/home_screen.dart` | Update queries for soft delete |
| Any delete functionality | Convert to soft delete |

---

## Progress Tracking

- [ ] Step 1: Review data structure
- [ ] Step 2: Create security rules
- [ ] Step 3: Deploy rules
- [ ] Step 4: Implement soft deletes
- [ ] Step 5: Update queries
- [ ] Step 6: Test all functionality
- [ ] Step 7: Update checklist

---

## Completion

When done, update:
1. `.code-review/MASTER_PLAN.md` - Change milestone 2.3 status to "Done"
2. `.code-review/checklists/phase-2-checklist.md` - Mark item complete
